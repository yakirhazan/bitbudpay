import * as axios from 'axios';
import * as _shared_clients_developer_controlled_wallets from './clients/developer-controlled-wallets';
import { TokenBlockchain, DeveloperControlledWalletsClient, FeeLevel, ContractExecutionBlockchain, TransactionType, Blockchain, Operation, TransactionState, WalletMetadata, AccountType, TokenStandard, ScaCore, EvmBlockchain } from './clients/developer-controlled-wallets';
export { AbiParametersInner, AccelerateTransactionForDeveloper, AccelerateTransactionForDeveloperData, AccelerateTransactionForDeveloperRequest, AccountType, Balance, Balances, BalancesData, BaseScreeningDecision, Blockchain, CancelTransactionForDeveloper, CancelTransactionForDeveloperRequest, ContractExecutionBlockchain, CreateContractExecutionTransactionForDeveloper, CreateContractExecutionTransactionForDeveloperRequest, CreateTransferTransactionForDeveloperRequest, CreateTransferTransactionForDeveloperResponse, CreateTransferTransactionForDeveloperResponseData, CreateWalletRequest, CreateWalletSetRequest, CreateWalletUpgradeTransactionForDeveloper, CreateWalletUpgradeTransactionForDeveloperRequest, CustodyType, DeveloperWalletSet, EOAWallet, EndUserWalletSet, EstimateContractExecutionTransactionFeeRequest, EstimateTransactionFee, EstimateTransactionFeeData, EstimateTransferTransactionFeeRequest, EvmBlockchain, FeeLevel, ListTransactionsOperationEnum, NewScaCore, Nft, Nfts, NftsData, Operation, RiskAction, RiskCategory, RiskScore, RiskSignal, RiskSignalSourceEnum, RiskType, SCAWallet, ScaCore, SignDelegateActionRequest, SignDelegateActionResponse, SignDelegateActionResponseData, SignMessageRequest, SignTransactionRequest, SignTransactionResponse, SignTransactionResponseData, SignTypedDataRequest, SignatureResponse, SignatureResponseData, TokenBlockchain, TokenResponse, TokenResponseData, TokenStandard, Transaction, TransactionFee, TransactionResponse, TransactionResponseData, TransactionScreeningDecision, TransactionState, TransactionType, Transactions, TransactionsData, UpdateWalletRequest, UpdateWalletSetRequest, ValidateAddress, ValidateAddressData, ValidateAddressRequest, Wallet, WalletMetadata, WalletResponse, WalletResponseData, WalletSet, WalletSetResponse, WalletSetResponseData, WalletSets, WalletSetsData, WalletSetsDataWalletSetsInner, WalletState, Wallets, WalletsData, WalletsDataWalletsInner, WalletsWithBalances, WalletsWithBalancesData, WalletsWithBalancesDataWalletsInner } from './clients/developer-controlled-wallets';
import * as _shared_core from './clients/core';
import { APIParams as APIParams$1, ClientParams as ClientParams$1, WithIdempotencyKey, FeeConfiguration, Pagination, TrimDataResponse, RequestTestnetTokensInput, CreateMonitoredTokensInput, UpdateMonitoredTokensInput, ListMonitoredTokensInput, DeleteMonitoredTokensInput, UpdateMonitoredTokensScopeInput, CreateSubscriptionInput, UpdateSubscriptionInput } from './clients/core';
export { APIParams as CoreAPIParams, ClientParams as CoreClientParams, CreateMonitoredTokensInput, CreateSubscriptionInput, DeleteMonitoredTokensInput, FeeConfiguration, ListMonitoredTokensInput, Pagination, RequestTestnetTokensInput, Storage, TrimDataResponse, UpdateMonitoredTokensInput, UpdateMonitoredTokensScopeInput, UpdateSubscriptionInput, WithIdempotencyKey } from './clients/core';
import * as _shared_clients_configurations from './clients/configurations';
export { BadRequestResponse, CreateMonitoredTokensRequest, CreateSubscriptionRequest, DeleteMonitoredTokensRequest, EntityConfig, EntityConfigData, FaucetRequest, ModelError, MonitoredTokens, MonitoredTokensData, NotAuthorizedResponse, NotFoundResponse, NotificationSignaturePublicKey, NotificationSignaturePublicKeyData, Ping, PublicKey, PublicKeyData, Subscription, SubscriptionResponse, Subscriptions, TestnetBlockchain, Token, TokenMonitorScope, UpdateMonitoredTokensRequest, UpdateMonitoredTokensScopeRequest, UpdateSubscriptionRequest } from './clients/configurations';

interface TokenIdInput {
    /**
     * System generated identifier of the token. Excluded with `tokenAddress` and `tokenBlockchain`.
     */
    tokenId: string;
    /**
     * Blockchain address of the transferred token. Empty for native tokens. Excluded with `tokenId`.
     */
    tokenAddress?: never;
    /**
     * Blockchain of the transferred token. Required if tokenId is not provided. Excluded with `tokenId`.
     */
    blockchain?: never;
}
interface TokenAddressAndBlockchainInput {
    /**
     * System generated identifier of the token. Excluded with `tokenAddress` and `tokenBlockchain`.
     */
    tokenId?: never;
    /**
     * Blockchain address of the transferred token. Empty for native tokens. Excluded with `tokenId`.
     */
    tokenAddress: string;
    /**
     * Blockchain of the transferred token. Required if tokenId is not provided. Excluded with `tokenId`.
     */
    blockchain?: TokenBlockchain;
}
/**
 * Type of the data that is stored.
 */
type StoredData = {
    /**
     * The publicKey that is associated to the entity.
     */
    publicKey: string;
};
interface Config {
    /**
     * Your configured entity secret.
     */
    entitySecret: string;
}
/**
 * Represents input parameters that can be either UserTokenInput or UserIdInput.
 */
type TokenInfo = TokenIdInput | TokenAddressAndBlockchainInput;
type APIParams = APIParams$1<DeveloperControlledWalletsClient, StoredData> & Config;
type ClientParams = ClientParams$1<StoredData> & Config;
/**
 * Represents the input to sign the EIP-191 message from a specified user-controlled wallet.
 */
type SignTransactionInput = {
    /**
     * System-generated unique identifier of the resource.
     */
    walletId: string;
    /**
     * Raw transaction string that needs to be signed. Excluded with `transaction`. Required without `transaction`.
     *
     * Required to be base64 encoded for NEAR, Solana chains. Required to be hex encoded for EVM chains.
     */
    rawTransaction?: string;
    /**
     * Transaction object in JSON that needs to be signed. Excluded with `rawTransaction`. Required without `rawTransaction`.
     *
     * NOTE: This field is only supported by `EVM` chains.
     */
    transaction?: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
};
/**
 * Represents the input to sign the EIP-191 message from a specified developer-controlled wallet.
 */
type SignMessageInput = {
    /**
     * Unique system generated identifier of the wallet.
     */
    walletId: string;
    /**
     * Indicator of whether the input message is encoded by hex. If TRUE, then the message should be a hex string. By default, it is False.
     */
    encodedByHex?: boolean;
    /**
     * The user friendly message that needs to be signed.
     * If it is a hex string, encodedByHex needs to be TRUE. The hex string should start with “0x” and have even length.
     */
    message: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
};
/**
 * Represents the input to sign the EIP-712 typed structured data from a specified developer-controlled wallet.
 */
type SignTypedDataInput = {
    /**
     * Unique system generated identifier of the wallet.
     */
    walletId: string;
    /**
     * A string represents the typed structured data in EIP-712.
     */
    data: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
};
/**
 * Represents the input parameters for retrieving a token.
 */
interface GetTokenInput {
    /**
     * The ID of the token to retrieve.
     */
    id: string;
}
/**
 * Represents the input parameters for accelerating a transaction.
 */
type AccelerateTransactionInput = {
    /**
     * The ID of the transaction to be accelerated.
     */
    id: string;
} & WithIdempotencyKey;
/**
 * Represents the input parameters for cancelling a transaction.
 */
type CancelTransactionInput = {
    /**
     * The ID of the transaction to be cancelled.
     */
    id: string;
} & WithIdempotencyKey;
/**
 * Represents the input parameters for creating a new transaction.
 */
type CreateTransactionInput = {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amounts: string[];
    /**
     * The recipient's blockchain address.
     */
    destinationAddress: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId: string;
    /**
     * The list of NFT IDs to be transferred/batchTransferred for NFT withdrawal.
     * Note: Only ERC-1155 tokens support safeBatchTransferFrom.
     */
    nftTokenIds?: string[];
    /**
     * An optional client-provided reference or description for the transaction.
     */
    refId?: string;
    /**
     * Configuration that determines the fees that will be paid.
     */
    fee: FeeConfiguration<FeeLevel>;
} & TokenInfo & WithIdempotencyKey;
/**
 * Represents the input parameters for creating a new contract execution transaction.
 */
type CreateContractExecutionTransactionInput = ({
    /**
     * The contract ABI function signature to be interacted with in the smart contract.
     * Example: `burn(uint256)`.
     */
    abiFunctionSignature: string;
    /**
     * The parameters required by the contract ABI function to perform the contract interaction.
     * Supported types include string, number, and boolean.
     */
    abiParameters: Array<any>;
    /**
     * The raw transaction data, must be an even-length hexadecimal string with the `0x` prefix.
     * `callData` cannot be used simultaneously with `abiFunctionSignature` or `abiParameters`.
     */
    callData?: undefined;
} | {
    /**
     * The contract ABI function signature to be interacted with in the smart contract.
     * Example: `burn(uint256)`.
     */
    abiFunctionSignature?: undefined;
    /**
     * The parameters required by the contract ABI function to perform the contract interaction.
     * Supported types include string, number, and boolean.
     */
    abiParameters?: undefined;
    /**
     * The raw transaction data, must be an even-length hexadecimal string with the `0x` prefix.
     * `callData` cannot be used simultaneously with `abiFunctionSignature` or `abiParameters`.
     */
    callData: `0x${string}`;
}) & {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amount?: string;
    /**
     * The blockchain address of the contract to be executed.
     */
    contractAddress: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId: string;
    /**
     * An optional client-provided reference or description for the transaction.
     */
    refId?: string;
    /**
     * Configuration that determines the fees that will be paid.
     */
    fee: FeeConfiguration<FeeLevel>;
} & WithIdempotencyKey;
/**
 * Defines the parameters for creating a new transfer transaction.
 */
type CreateTransferTransactionInput = {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amount: string[];
    /**
     * The recipient's blockchain address.
     */
    destinationAddress: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId: string;
    /**
     * The list of NFT IDs to be transferred/batchTransferred for NFT withdrawal.
     * Note: Only erc1155 supports safeBatchTransferFrom.
     */
    nftTokenIds?: string[];
    /**
     * An optional client-provided reference or description for the transaction.
     */
    refId?: string;
    /**
     * Configuration to determine the fees that will be paid.
     */
    fee: FeeConfiguration<FeeLevel>;
} & WithIdempotencyKey & TokenInfo;
/**
 * Represents the input parameters for estimating transfer fees.
 */
type EstimateContractExecutionFeeInput = ({
    /**
     * The contract ABI function signature to be interacted with in the smart contract. For example, `burn(uint256)`.
     */
    abiFunctionSignature: string;
    /**
     * The parameters required by the contract ABI function to perform the contract interaction.
     */
    abiParameters: Array<any>;
    /**
     * The raw transaction data, must be an even-length hexadecimal string with the 0x prefix, to be executed.
     * It is important to note that the usage of callData is mutually exclusive with the abiFunctionSignature and abiParameters.
     * Therefore, callData cannot be utilized simultaneously with either abiFunctionSignature or abiParameters.
     */
    callData?: undefined;
} | {
    /**
     * The contract ABI function signature to be interacted with in the smart contract. For example, `burn(uint256)`.
     */
    abiFunctionSignature?: undefined;
    /**
     * The parameters required by the contract ABI function to perform the contract interaction.
     */
    abiParameters?: undefined;
    /**
     * The raw transaction data, must be an even-length hexadecimal string with the 0x prefix, to be executed.
     * It is important to note that the usage of callData is mutually exclusive with the abiFunctionSignature and abiParameters.
     * Therefore, callData cannot be utilized simultaneously with either abiFunctionSignature or abiParameters.
     */
    callData: `0x${string}`;
}) & {
    /**
     * The blockchain address of the contract to be executed.
     */
    contractAddress: string;
    /**
     * Information about the source.
     */
    source: {
        /**
         * Identifier for the originating wallet.
         */
        walletId: string;
    } | {
        /**
         * Blockchain associated with the transaction. Required along with sourceAddress.
         */
        blockchain: ContractExecutionBlockchain;
        /**
         * The source blockchain address of the transaction.
         */
        sourceAddress: string;
    };
};
/**
 * Represents the input parameters for estimating transfer fees.
 */
type EstimateTransferFeeInput = {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amount: string[];
    /**
     * The recipient's blockchain address.
     */
    destinationAddress: string;
    /**
     * The source blockchain address of the transaction.
     */
    sourceAddress?: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId?: string;
    /**
     * The list of NFT IDs to be transferred/batchTransferred for NFT withdrawal.
     * Note: Only ERC-1155 tokens support safeBatchTransferFrom.
     */
    nftTokenIds?: string[];
} & TokenInfo;
/**
 * Represents the input for retrieving a transaction.
 */
interface GetTransactionInput {
    /**
     * The ID of the transaction to retrieve.
     */
    id: string;
    /**
     * Filters on the transaction type of the transaction.
     */
    txType?: TransactionType;
}
/**
 * Defines the parameters for querying a list of transactions.
 */
type ListTransactionsInput = {
    /**
     * Filters transactions based on the blockchain they occur on.
     */
    blockchain?: Blockchain;
    /**
     * Filters transactions based on their destination address.
     */
    destinationAddress?: string;
    /**
     * Determines if the query should include all tokens.
     * If set to true, results will include all tokens.
     */
    includeAll?: boolean;
    /**
     * Filters transactions based on their operation.
     */
    operation?: Operation;
    /**
     * Filters transactions based on their current state.
     */
    state?: TransactionState;
    /**
     * Filters for a specific transaction hash.
     */
    txHash?: string;
    /**
     * Filters transactions based on their type.
     */
    txType?: TransactionType;
    /**
     * Filters transactions based on the owning wallets.
     * Input should be an array of walletIds.
     */
    walletIds?: string[];
} & Pagination;
/**
 * Represents the input parameters for validating an address.
 */
interface ValidateAddressInput {
    /**
     * The blockchain address to be validated.
     */
    address: string;
    /**
     * The blockchain that the address should belong to.
     */
    blockchain: Blockchain;
}
/**
 * Represents the input for creating multiple wallets.
 */
type CreateWalletsInput = {
    /**
     * The blockchains for which to create wallets.
     */
    blockchains: Blockchain[];
    /**
     * The number of wallets to create for each selected blockchain.
     * This count will be multiplied by the number of selected blockchains.
     * For example, with count=2 and blockchains.length=2, it will create a total of 4 new wallets.
     */
    count: number;
    /**
     * Optional list of metadata fields to associate with the corresponding wallet.
     * If count is specified, the amount of items in the array should match the count field.
     */
    metadata?: WalletMetadata[];
    /**
     * The ID of the wallet set for which to create the wallets.
     */
    walletSetId: string;
    /**
     * An account can be categorized as a Smart Contract Account (SCA) or an Externally Owned Account (EOA). For detailed information about these account types and their distinctions, please refer to the account types guide.
     *
     * By default, if an account type is not specified when creating a wallet, it will be classified as an Externally Owned Account (EOA).
     */
    accountType?: AccountType;
} & WithIdempotencyKey;
/**
 * Represents the input for retrieving a wallet.
 */
interface GetWalletInput {
    /**
     * The ID of the wallet to retrieve.
     */
    id: string;
}
/**
 * Represents the input for retrieving the nft balance of a wallet.
 */
type GetWalletNFTBalanceInput = {
    /**
     * The ID of the wallet to retrieve the nfts for.
     */
    id: string;
    /**
     * Specifies whether to include all token.
     */
    includeAll?: boolean;
    /**
     * The name of the token to filter for.
     */
    name?: string;
    /**
     * An array of token addresses.
     */
    tokenAddresses?: string[];
    /**
     * Token standard.
     */
    standard?: TokenStandard;
} & Omit<Pagination, 'from' | 'to'>;
/**
 * Represents the input for retrieving the token balance of a wallet.
 */
type GetWalletTokenBalanceInput = {
    /**
     * The ID of the wallet to retrieve the tokens for.
     */
    id: string;
    /**
     * Specifies whether to include all tokens.
     */
    includeAll?: boolean;
    /**
     * The name of the token to filter for.
     */
    name?: string;
    /**
     * An array of token addresses.
     */
    tokenAddresses?: string[];
    /**
     * Token standard.
     */
    standard?: TokenStandard;
} & Omit<Pagination, 'from' | 'to'>;
/**
 * Represents the input for listing wallets.
 */
type ListWalletsInput = {
    /**
     * The address of the wallet to filter by.
     */
    address?: string;
    /**
     * The blockchain to filter by.
     */
    blockchain?: Blockchain;
    /**
     * The ID of the wallet set to filter by.
     */
    walletSetId?: string;
    /**
     * Reference or description used to identify the wallet.
     */
    refId?: string;
    /**
     * Filters results by the SCA version.
     */
    scaCore?: ScaCore;
} & Pagination;
/**
 * Represents the input for updating a wallet.
 */
interface UpdateWalletInput {
    /**
     * The ID of the wallet to be updated.
     */
    id: string;
    /**
     * The new name for the wallet.
     */
    name?: string;
    /**
     * The new refId for the wallet.
     */
    refId?: string;
}
/**
 * Represents the input for creating a wallet set.
 */
type CreateWalletSetInput = {
    /**
     * The name you want to apply to your wallet set.
     */
    name: string;
} & WithIdempotencyKey;
/**
 * Represents the input for retrieving a wallet set.
 */
interface GetWalletSetInput {
    /**
     * The ID of the wallet set to retrieve.
     */
    id: string;
}
/**
 * Represents the input for listing wallet sets.
 */
type ListWalletSetsInput = {
    /**
     * Developer-provided parameter used to identify this request.
     */
    xRequestId?: string;
} & Pagination;
/**
 * Represents the input for updating a wallet set.
 */
interface UpdateWalletSetInput {
    /**
     * The ID of the wallet set to be updated.
     */
    id: string;
    /**
     * The new name for the wallet set.
     */
    name: string;
}
/**
 * Parameters for registering the entity secret cipher text.
 */
type RegisterEntitySecretCipherTextInput = {
    /**
     * ApiKey that will be used to authenticate the request.
     */
    apiKey: string;
    /**
     * New Entity Secret that you want to be registered.
     */
    entitySecret: string;
    /**
     * Relative path to download the recovery file.
     */
    recoveryFileDownloadPath?: string;
    /**
     * Optional base URL to override the default: `https://api.circle.com`.
     */
    baseUrl?: string;
};
/**
 * Parameters for generating a new the entity secret cipher text.
 */
type GenerateEntitySecretCipherTextInput = {
    /**
     * ApiKey that will be used to authenticate the request.
     */
    apiKey: string;
    /**
     * Entity Secret.
     */
    entitySecret: string;
    /**
     * Optional base URL to override the default: `https://api.circle.com`.
     */
    baseUrl?: string;
};
/**
 * Parameters for registering the entity secret cipher text.
 */
type RegisterEntitySecretCipherTextResponse = {
    data: {
        /**
         * Your recoveryFile.
         */
        recoveryFile: string;
    };
};
/**
 * Parameters for signing a delegate action.
 */
interface SignDelegateActionInput {
    /**
     * System-generated unique identifier of the resource.
     */
    walletId: string;
    /**
     * Unsigned delegate action string that needs to be signed. Must be base64 encoded.
     */
    unsignedDelegateAction: string;
}
/**
 * Parameters for deriving a wallet.
 */
type DeriveWalletInput = {
    /**
     * Developer-provided parameter used to identify this request.
     */
    xRequestId?: string;
    /**
     * The ID of the wallet to derive from.
     */
    id: string;
    /**
     * The blockchain to derive the Wallet for.
     */
    blockchain: EvmBlockchain;
    /**
     * Optional list of metadata fields to associate with the corresponding wallet.
     * If count is specified, the amount of items in the array should match the count field.
     */
    metadata?: WalletMetadata;
};
/**
 * Represents the input for listing wallets.
 */
type GetWalletsWithBalancesInput = {
    /**
     * Developer-provided parameter used to identify this request.
     */
    xRequestId?: string;
    /**
     * The address of the wallet to filter by.
     */
    address?: string;
    /**
     * The blockchain to filter by.
     */
    blockchain: Blockchain;
    /**
     * The ID of the wallet set to filter by.
     */
    walletSetId?: string;
    /**
     * Reference or description used to identify the wallet.
     */
    refId?: string;
    /**
     * Filters results by the SCA version.
     */
    scaCore?: ScaCore;
    /**
     * Blockchain address of the transferred token. Empty for native tokens.
     */
    tokenAddress?: string;
    /**
     * Filters wallets where the balance is greater than or equal to the specified amount. Applies to the specified token if tokenAddress is provided; otherwise, to the native token.
     */
    amountGte?: string;
} & Pagination;

/**
 * Helper function to register the entity secret for the first time and downloads the recovery file.
 * This is non idempotent process, so make sure you save the recovery file or the entity secret some place secure.
 * @example
 * ```
 * import * as fs from "fs";
 * import { registerEntitySecretCiphertext } from "@circle-fin/developer-controlled-wallets";
 * const response = await registerEntitySecretCiphertext({
 *   apiKey: "<api-key>",
 *   entitySecret: "<entity-secret>",
 * });
 * fs.writeFileSync("recovery_file.dat", response.data?.recoveryFile ?? "");
 * ```
 * @category Developer Account
 * @param input - Input required to register the entity secret ciphertext. API key and entity secret are required.
 */
declare function registerEntitySecretCiphertext(input: RegisterEntitySecretCipherTextInput): Promise<TrimDataResponse<RegisterEntitySecretCipherTextResponse>>;
/**
 * Helper function to generate a new entity secret.
 *
 * NOTE: This function prints the entity secret to the console and does not return anything.
 * @example
 * ```
 * import { generateEntitySecret } from '@circle-fin/developer-controlled-wallets'
 *
 * generateEntitySecret()
 * ```
 * @category Developer Account
 */
declare function generateEntitySecret(): void;

declare const defaultBaseUrl = "https://api.circle.com";
/**
 * A class-based client for Circle's Developer Controlled Wallets.
 * All operations are available as class methods.
 * @example
 * ```
 * import { CircleDeveloperControlledWalletsClient } from '@circle-fin/developer-controlled-wallets'
 *
 * const client = new CircleDeveloperControlledWalletsClient({
 *   apiKey: 'YOUR_KEY',
 *   entitySecret: 'YOUR_SECRET',
 * })
 *
 * const response = await client.listWallets()
 * console.log(response.data?.wallets)
 * ```
 */
declare class CircleDeveloperControlledWalletsClient {
    private readonly params;
    /**
     * Creates an instance of CircleDeveloperControlledWalletsClient.
     * @param config - API key, entity secret, optional baseUrl.
     */
    constructor(config: ClientParams);
    /**
     * Get the public key associated with your entity.
     * @example
     * ```
     * const response = await client.getPublicKey()
     * console.log(response.data.publicKey)
     * ```
     * @category Developer Account
     */
    getPublicKey(): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.PublicKey>>;
    /**
     * Fetches details of a specific token given its unique identifier.
     *
     * Every token in your network of wallets has a UUID associated with it,
     * regardless of whether it's already recognized or was added as a monitored token.
     * @example
     * ```
     * const response = await client.getToken({
     *   id: 'uuid-token-id',
     * })
     * console.log(response.data?.token)
     * ```
     * @category Token Lookup
     */
    getToken({ id }: GetTokenInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.TokenResponse>>;
    /**
     * Request testnet tokens for your wallet.
     * @example
     * ```
     * const response = await client.requestTestnetTokens({
     *   address: '0xb395f4ea0ba29494ce839613fffba74279579269',
     *   blockchain: TestnetBlockchain.EthSepolia,
     *   usdc: true,
     * })
     * console.log(response.status)
     * ```
     * @category Faucet
     */
    requestTestnetTokens(input: RequestTestnetTokensInput): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Add a new token to the monitored token list.
     * @example
     * ```
     * const response = await client.createMonitoredTokens({
     *   tokenIds: ['4fdb0a55-cb17-4db5-b5a7-2cca2b26dfd6'],
     * })
     * console.log(response)
     * ```
     * @category Monitored Tokens
     */
    createMonitoredTokens(input: CreateMonitoredTokensInput): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.MonitoredTokens>>;
    /**
     * Edit the monitored token list.
     * @example
     * ```
     * const response = await client.updateMonitoredTokens({
     *   tokenIds: ['4fdb0a55-cb17-4db5-b5a7-2cca2b26dfd6'],
     * })
     * console.log(response)
     * ```
     * @category Monitored Tokens
     */
    updateMonitoredTokens(input: UpdateMonitoredTokensInput): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.MonitoredTokens>>;
    /**
     * Get monitored tokens.
     * @example
     * ```
     * const response = await client.listMonitoredTokens()
     * console.log(response)
     * ```
     * @category Monitored Tokens
     */
    listMonitoredTokens(input?: ListMonitoredTokensInput): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.MonitoredTokens>>;
    /**
     * Delete tokens from the monitored token list.
     * @example
     * ```
     * const response = await client.deleteMonitoredTokens({
     *   tokenIds: ['4fdb0a55-cb17-4db5-b5a7-2cca2b26dfd6'],
     * })
     * console.log(response)
     * ```
     * @category Monitored Tokens
     */
    deleteMonitoredTokens(input: DeleteMonitoredTokensInput): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Select between monitoring all tokens or selected tokens added to the monitored tokens list.
     * @example
     * ```
     * const response = await client.updateMonitoredTokensScope({
     *   scope: 'MONITOR_ALL',
     * })
     * console.log(response)
     * ```
     * @category Monitored Tokens
     */
    updateMonitoredTokensScope(input: UpdateMonitoredTokensScopeInput): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Create a notification subscription by configuring an endpoint to receive notifications.
     *
     * For details, see the [Notification Flows](https://developers.circle.com/w3s/docs/notification-flows) guide.
     * @example
     * ```
     * const response = await client.createSubscription({
     *   endpoint: 'https://example.org/handler/for/notifications',
     * })
     * console.log(response)
     * ```
     * @category Webhook Subscriptions
     */
    createSubscription(input: CreateSubscriptionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.SubscriptionResponse>>;
    /**
     * Delete a notification subscription.
     * @example
     * ```
     * const response = await client.deleteSubscription('b3d9d2d5-4c12-4946-a09d-953e82fae2b0')
     * console.log(response)
     * ```
     * @category Webhook Subscriptions
     */
    deleteSubscription(subscriptionId: string): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Retrieve an existing notification subscription.
     * @example
     * ```
     * const response = await client.getSubscription('b3d9d2d5-4c12-4946-a09d-953e82fae2b0')
     * console.log(response)
     * ```
     * @category Webhook Subscriptions
     */
    getSubscription(subscriptionId: string): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.SubscriptionResponse>>;
    /**
     * Get the public key and algorithm used to digitally sign webhook notifications. Verifying the digital signature ensures the notification came from Circle.
     * In the headers of each webhook, you can find
     * 1. `X-Circle-Signature`: a header containing the digital signature generated by Circle.
     * 2. `X-Circle-Key-Id`: a header containing the UUID. This is will be used as the `ID` as URL parameter to retrieve the relevant public key.
     * @example
     * ```
     * const response = await client.getNotificationSignature('b3d9d2d5-4c12-4946-a09d-953e82fae2b0')
     * console.log(response)
     * ```
     * @category Webhook Subscriptions
     */
    getNotificationSignature(subscriptionId: string): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.NotificationSignaturePublicKey>>;
    /**
     * Retrieve an array of existing notification subscriptions.
     * @example
     * ```
     * const response = await client.listSubscriptions()
     * console.log(response)
     * ```
     * @category Webhook Subscriptions
     */
    listSubscriptions(): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.Subscriptions>>;
    /**
     * Update subscription endpoint to receive notifications.
     * @example
     * ```
     * const response = await client.updateSubscription({
     *   id: 'b3d9d2d5-4c12-4946-a09d-953e82fae2b0',
     *   name: 'payment-processor',
     *   enabled: true,
     * })
     * console.log(response)
     * ```
     * @category Webhook Subscriptions
     */
    updateSubscription(input: UpdateSubscriptionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.SubscriptionResponse>>;
    /**
     * Accelerates a specified transaction from a developer-controlled wallet.
     *
     * Additional gas fees may be incurred.
     * @example
     * ```
     * const response = await client.accelerateTransaction({
     *   id: "transaction-id",
     * })
     * console.log(response.data?.id)
     * ```
     * @category Transactions
     */
    accelerateTransaction(input: AccelerateTransactionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.AccelerateTransactionForDeveloper>>;
    /**
     * Cancels a specified transaction from a developer-controlled wallet.
     * Gas fees may still be incurred.
     *
     * This is a best-effort operation, it won\'t be effective if the original transaction has already been processed by the blockchain.
     * @example
     * ```
     * const response = await client.cancelTransaction({
     *   id: "transaction-id",
     * })
     * console.log(response.data)
     * ```
     * @category Transactions
     */
    cancelTransaction(input: CancelTransactionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.CancelTransactionForDeveloper>>;
    /**
     * Creates a transaction which executes a smart contract. ABI parameters must be passed in the request.
     * Related transactions may be submitted as a batch transaction in a single call.
     * @example
     * ```
     * const response = await client.createContractExecutionTransaction({
     *   amount: '0.01',
     *   abiFunctionSignature: 'burn(uint256)',
     *   contractAddress: '0xa51c9c604b79a0fadbfed35dd576ca1bce71da0a',
     *   walletId: 'a635d679-4207-4e37-b12e-766afb9b3892',
     *   fee: {
     *     type: 'level',
     *     config: {
     *       feeLevel: 'HIGH',
     *     },
     *   },
     * })
     * console.log(response.data)
     * ```
     * @category Transactions
     */
    createContractExecutionTransaction(input: CreateContractExecutionTransactionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.CreateContractExecutionTransactionForDeveloper>>;
    /**
     * Initiates an on-chain digital asset transfer from a specified developer-controlled wallet.
     * @example
     * ```
     * const response = await client.createTransaction({
     *   amount: ['0.01'],
     *   destinationAddress: '0xa51c9c604b79a0fadbfed35dd576ca1bce71da0a',
     *   tokenId: '738c8a6d-8896-46d1-b2cb-083600c1c69b',
     *   walletId: 'a635d679-4207-4e37-b12e-766afb9b3892',
     *   fee: {
     *     type: 'level',
     *     config: {
     *       feeLevel: 'HIGH',
     *     },
     *   },
     * })
     * console.log(response.data)
     * ```
     * @category Transactions
     */
    createTransaction(input: CreateTransferTransactionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.CreateTransferTransactionForDeveloperResponse>>;
    /**
     * Retrieves info for a single transaction using it's unique identifier.
     * @example
     * ```
     * const response = await client.getTransaction({
     *   id: '9fcb2e86-dec2-4226-81d1-4dbad429278c',
     * })
     * console.log(response.data?.transaction)
     * ```
     * @category Transactions
     */
    getTransaction(input: GetTransactionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.TransactionResponse>>;
    /**
     * Lists all transactions. Includes details such as status, source/destination, and transaction hash.
     * @example
     * ```
     * const response = await client.listTransactions()
     * console.log(response.data?.transactions)
     * ```
     * @category Transactions
     */
    listTransactions(input?: ListTransactionsInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.Transactions>>;
    /**
     * Estimates gas fees that will be incurred for a contract execution transaction, given its ABI parameters and blockchain.
     * @example
     * ```
     * const response = await client.estimateContractExecutionFee({
     *   abiFunctionSignature: 'burn(uint256)',
     *   abiParameters: [1000],
     *   contractAddress: '656d6fd6-d430-459c-9ba4-5c2074433f1b',
     *   source: {
     *     walletId: '9a014a34-4706-4e3f-879d-fc2a8764877c',
     *   },
     * })
     * console.log(response.data)
     * ```
     * @category Transactions
     */
    estimateContractExecutionFee(input: EstimateContractExecutionFeeInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.EstimateTransactionFee>>;
    /**
     * Estimates gas fees that will be incurred for a transfer transaction; given its amount, blockchain, and token.
     * @example
     * ```
     * const response = await client.estimateTransferFee({
     *   amount: ['0.01'],
     *   destinationAddress: '656d6fd6-d430-459c-9ba4-5c2074433f1b',
     *   tokenId: '9606f293-5b81-4970-acd3-c35c157461c2',
     * })
     * console.log(response.data)
     * ```
     * @category Transactions
     */
    estimateTransferFee(input: EstimateTransferFeeInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.EstimateTransactionFee>>;
    /**
     * Confirms that a specified address is valid for a given token on a certain blockchain.
     * @example
     * ```
     * const response = await client.validateAddress({
     *   address: '0xa95f8fafb3f6ae0f9ba7204eef07bde7a64cf2bc',
     *   blockchain: 'ETH-SEPOLIA',
     * })
     * console.log(response.data?.isValid)
     * ```
     * @category Transactions
     */
    validateAddress(input: ValidateAddressInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.ValidateAddress>>;
    /**
     * Generates a new developer-controlled wallet or batch of wallets within a wallet set, specifying blockchain and wallet name.
     * @example
     * ```
     * const response = await client.createWallets({
     *   blockchains: ["MATIC-AMOY"],
     *   count: 1,
     *   walletSetId: "67eb6eac-a7f5-4c04-9200-2fbf969426b0",
     * })
     * console.log(response.data?.wallets)
     * ```
     * @category Wallets
     */
    createWallets(input: CreateWalletsInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.Wallets>>;
    /**
     * Retrieves a list of all wallets that fit the specified parameters.
     * @example
     * ```
     * const response = await client.listWallets()
     * console.log(response.data?.wallets)
     * ```
     * @category Wallets
     */
    listWallets(input?: ListWalletsInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.Wallets>>;
    /**
     * Retrieve an existing wallet using its unique identifier.
     * @example
     * ```
     * const response = await client.getWallet({
     *   id: '223d9a78-ca33-4cbd-ab83-8f083e3c045b',
     * })
     * console.log(response.data?.wallet)
     * ```
     * @category Wallets
     */
    getWallet(input: GetWalletInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.WalletResponse>>;
    /**
     * Update information for a specific wallet using its unique identifier.
     * @example
     * ```
     * const response = await client.updateWallet({
     *   id: '1f29cce1-ab6c-41ad-84d8-9d223d014881',
     *   name: 'Updated name',
     * })
     * console.log(response.data?.wallet)
     * ```
     * @category Wallets
     */
    updateWallet(input: UpdateWalletInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.WalletResponse>>;
    /**
     * Fetches the digital asset balance for a single developer-controlled wallet using its unique identifier.
     * @example
     * ```
     * const response = await client.getWalletTokenBalance({
     *   id: 'e518abf8-882d-4fa1-931e-596b28aa970b',
     * })
     * console.log(response.data?.tokenBalances)
     * ```
     * @category Wallets
     */
    getWalletTokenBalance(input: GetWalletTokenBalanceInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.Balances>>;
    /**
     * Fetches the info for all NFTs stored in a single developer-controlled wallet, using the wallets unique identifier.
     * @example
     * ```
     * const response = await client.getWalletNFTBalance({
     *   id: 'b21c473f-8c93-4826-90f5-cad3cfeef4c1',
     * })
     * console.log(response.data?.nfts)
     * ```
     * @category Wallets
     */
    getWalletNFTBalance(input: GetWalletNFTBalanceInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.Nfts>>;
    /**
     * Derives an EOA wallet using the address of the specified wallet and blockchain. If the target wallet already exists, its metadata will be updated with the provided metadata.
     *
     * NOTE: This endpoint is only available for EVM-based wallets.
     * @example
     * ```
     * const response = await client.deriveWallet({
     *   id: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     *   blockchain: 'ETH',
     * })
     * console.log(response.data?.wallet)
     * ```
     * @category Wallets
     */
    deriveWallet(input: DeriveWalletInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.WalletResponse>>;
    /**
     * Retrieves a list of all wallets that fit the specified parameters, including native balances and USDC/EURC token balances if specified.
     *
     * NOTE: Balances update automatically with transfers or via the [Get token balance for a wallet](https://developers.circle.com/api-reference/w3s/developer-controlled-wallets/list-wallet-balance) for accuracy.
     * @example
     * ```
     * const response = await client.getWalletsWithBalances({
     *  blockchain: 'ETH-SEPOLIA',
     *  amountGte: '1',
     * })
     * console.log(response.data?.wallets)
     * ```
     * @category Wallets
     */
    getWalletsWithBalances(input: GetWalletsWithBalancesInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.WalletsWithBalances>>;
    /**
     * Create a developer controlled wallet set.
     * @example
     * ```
     * const response = await client.createWalletSet({
     *   name: 'My first wallet set',
     * })
     * console.log(response.data?.walletSet)
     * ```
     * @category Wallet Sets
     */
    createWalletSet(input: CreateWalletSetInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.WalletSetResponse>>;
    /**
     * Retrieve an existing wallet set.
     * @example
     * ```
     * const response = await client.getWalletSet({
     *   id: 'd1daae42-6853-4d66-8184-65468e95225b',
     * })
     * console.log(response.data?.walletSet)
     * ```
     * @category Wallet Sets
     */
    getWalletSet(input: GetWalletSetInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.WalletSetResponse>>;
    /**
     * Retrieve a list of all wallet sets.
     * @example
     * ```
     * const response = await client.listWalletSets()
     * console.log(response.data?.walletSets)
     * ```
     * @category Wallet Sets
     */
    listWalletSets(input?: ListWalletSetsInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.WalletSets>>;
    /**
     * Update the name of the wallet set using its ID.
     * @example
     * ```
     * const response = await client.updateWalletSet({
     *   id: 'b26bb9f9-7b85-48e2-a613-1923fb470e2e',
     *   name: 'My new walletSet name',
     * })
     * console.log(response.data?.walletSet)
     * ```
     * @category Wallet Sets
     */
    updateWalletSet(input: UpdateWalletSetInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.WalletSetResponse>>;
    /**
     * Sign the EIP-191 message from a specified developer-controlled wallet.
     * Please note that not all the Dapps currently support Smart Contract Account (SCA),
     * the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types),
     * and you can check the list of Dapps that support SCA: https://eip1271.io/.
     * @example
     * ```
     * const response = await client.signMessage({
     *   walletId: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     *   encodedByHex: false,
     *   message: 'I agree with this transfer',
     *   memo: 'Transfer USDC to Sam',
     * })
     * console.log(response.data?.signature)
     * ```
     * @category Signing
     */
    signMessage(input: SignMessageInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.SignatureResponse>>;
    /**
     * Sign the EIP-712 typed structured data from a specified developer-controlled wallet.
     * Please note that not all the Dapps currently support Smart Contract Account (SCA),
     * the difference between EOA and SCA can be found in the [account types guide](https://developers.circle.com/w3s/docs/programmable-wallets-account-types),
     * and you can check the list of Dapps that support SCA: https://eip1271.io/.
     * @example
     * ```
     * const response = await client.signTypedData({
     *   walletId: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     *   data: '{ "types": { "Data": [{ "name": "dummy", "type": "string" }],}, "domain": { "name": "Test", "chainId": 1337 }, "primaryType": "Data", "message": { "dummy": "dummy" }}',
     *   memo: 'Transfer USDC to Sam',
     * })
     * console.log(response.data?.signature)
     * ```
     * @category Signing
     */
    signTypedData(input: SignTypedDataInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.SignatureResponse>>;
    /**
     * Sign a transaction from a specific developer-controlled wallet.
     * NOTE: This endpoint is only available for the following chains: `SOL`, `SOL-DEVNET`, `NEAR`, `NEAR-TESTNET`, `EVM`, `EVM-TESTNET`.
     * Each chain defines its own standard, please refer to [Signing APIs doc](https://learn.circle.com/w3s/signing-apis).
     * @example
     * ```
     * const response = await client.signTransaction({
     *   walletId: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     *   rawTransaction: 'ZGVlcGFrcm...VkZHlndW1taQ==',
     *   memo: 'Transfer USDC to Sam',
     * })
     * console.log(response.data?.signature)
     * ```
     * @category Signing
     */
    signTransaction(input: SignTransactionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.SignTransactionResponse>>;
    /**
     * Sign a delegate action from a specific developer-controlled wallet.
     *
     * NOTE: This endpoint is only available for NEAR and NEAR-TESTNET.
     * @example
     * ```
     * const response = await client.signDelegateAction({
     *   walletId: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     *   unsignedDelegateAction: 'ASVlcGFrcm...VkZHlndW1taS==',
     * })
     * console.log(response.data?.signature)
     * ```
     * @category Signing
     */
    signDelegateAction(input: SignDelegateActionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_developer_controlled_wallets.SignDelegateActionResponse>>;
    /**
     * Generate a new entity secret.
     * @example
     * ```
     * const entitySecretCiphertext = await client.generateEntitySecretCiphertext()
     * console.log(entitySecretCiphertext)
     * ```
     * @category Developer Account
     */
    generateEntitySecretCiphertext(): Promise<string>;
}
/**
 * Initiates a client for Circle's Developer Controlled Wallets.
 * @example
 * ```
 * import { initiateDeveloperControlledWalletsClient } from '@circle-fin/developer-controlled-wallets'
 *
 * const client = initiateDeveloperControlledWalletsClient({
 *   apiKey: 'YOUR_KEY',
 *   entitySecret: 'YOUR_SECRET',
 *   baseUrl: 'https://api.circle.com',
 * })
 *
 * const response = await client.listWallets()
 * console.log(response.data?.wallets)
 * ```
 * @param config - The client parameters.
 * @category Initialization
 * @returns - The client object with various methods.
 */
declare function initiateDeveloperControlledWalletsClient(config: ClientParams): CircleDeveloperControlledWalletsClient;
/**
 * A standalone function example, if you need it separately:
 * Generates a new Entity Secret Ciphertext.
 * @example
 * ```
 * const secret = await generateEntitySecretCiphertext({
 *   apiKey: '...',
 *   entitySecret: '...',
 * })
 * console.log(secret)
 * ```
 * @category Developer Account
 */
declare function generateEntitySecretCiphertext(input: GenerateEntitySecretCipherTextInput): Promise<string>;

export { type APIParams, type AccelerateTransactionInput, type CancelTransactionInput, CircleDeveloperControlledWalletsClient, type ClientParams, type Config, type CreateContractExecutionTransactionInput, type CreateTransactionInput, type CreateTransferTransactionInput, type CreateWalletSetInput, type CreateWalletsInput, type DeriveWalletInput, type EstimateContractExecutionFeeInput, type EstimateTransferFeeInput, type GenerateEntitySecretCipherTextInput, type GetTokenInput, type GetTransactionInput, type GetWalletInput, type GetWalletNFTBalanceInput, type GetWalletSetInput, type GetWalletTokenBalanceInput, type GetWalletsWithBalancesInput, type ListTransactionsInput, type ListWalletSetsInput, type ListWalletsInput, type RegisterEntitySecretCipherTextInput, type RegisterEntitySecretCipherTextResponse, type SignDelegateActionInput, type SignMessageInput, type SignTransactionInput, type SignTypedDataInput, type StoredData, type TokenAddressAndBlockchainInput, type TokenIdInput, type TokenInfo, type UpdateWalletInput, type UpdateWalletSetInput, type ValidateAddressInput, defaultBaseUrl, generateEntitySecret, generateEntitySecretCiphertext, initiateDeveloperControlledWalletsClient, registerEntitySecretCiphertext };
