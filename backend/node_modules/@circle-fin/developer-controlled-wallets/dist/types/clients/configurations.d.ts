import * as axios from 'axios';
import { AxiosRequestConfig, AxiosInstance, AxiosPromise } from 'axios';

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    serverIndex?: number;
    baseOptions?: any;
    formDataCtor?: new () => any;
}
declare class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    /**
     * override server index
     *
     * @type {number}
     * @memberof Configuration
     */
    serverIndex?: number;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;
    constructor(param?: ConfigurationParameters);
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime: string): boolean;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface RequestArgs
 */
interface RequestArgs {
    url: string;
    options: AxiosRequestConfig;
}
/**
 *
 * @export
 * @class BaseAPI
 */
declare class BaseAPI {
    protected basePath: string;
    protected axios: AxiosInstance;
    protected configuration: Configuration | undefined;
    constructor(configuration?: Configuration, basePath?: string, axios?: AxiosInstance);
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface BadRequestResponse
 */
interface BadRequestResponse {
    /**
     * Code that corresponds to the error.
     * @type {number}
     * @memberof BadRequestResponse
     */
    'code': number;
    /**
     * Message that describes the error.
     * @type {string}
     * @memberof BadRequestResponse
     */
    'message': string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The blockchain network that the resource is to be created on or is currently on.
 * @export
 * @enum {string}
 */
declare const Blockchain: {
    readonly Eth: "ETH";
    readonly EthSepolia: "ETH-SEPOLIA";
    readonly Avax: "AVAX";
    readonly AvaxFuji: "AVAX-FUJI";
    readonly Matic: "MATIC";
    readonly MaticAmoy: "MATIC-AMOY";
    readonly Sol: "SOL";
    readonly SolDevnet: "SOL-DEVNET";
    readonly Arb: "ARB";
    readonly ArbSepolia: "ARB-SEPOLIA";
    readonly Near: "NEAR";
    readonly NearTestnet: "NEAR-TESTNET";
    readonly Evm: "EVM";
    readonly EvmTestnet: "EVM-TESTNET";
    readonly Uni: "UNI";
    readonly UniSepolia: "UNI-SEPOLIA";
    readonly Base: "BASE";
    readonly BaseSepolia: "BASE-SEPOLIA";
    readonly Op: "OP";
    readonly OpSepolia: "OP-SEPOLIA";
};
type Blockchain = typeof Blockchain[keyof typeof Blockchain];

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateMonitoredTokensRequest
 */
interface CreateMonitoredTokensRequest {
    /**
     * The list of tokens to add to the monitored tokens list. When fetching wallet balances, only these tokens will be shown by default.
     * @type {Array<string>}
     * @memberof CreateMonitoredTokensRequest
     */
    'tokenIds': Array<string>;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @enum {string}
 */
declare const NotificationType: {
    readonly Star: "*";
    readonly Transactions: "transactions.*";
    readonly TransactionsInbound: "transactions.inbound";
    readonly TransactionsOutbound: "transactions.outbound";
    readonly Challenges: "challenges.*";
    readonly ChallengesAccelerateTransaction: "challenges.accelerateTransaction";
    readonly ChallengesCancelTransaction: "challenges.cancelTransaction";
    readonly ChallengesChangePin: "challenges.changePin";
    readonly ChallengesContractExecution: "challenges.contractExecution";
    readonly ChallengesCreateTransaction: "challenges.createTransaction";
    readonly ChallengesCreateWallet: "challenges.createWallet";
    readonly ChallengesInitialize: "challenges.initialize";
    readonly ChallengesRestorePin: "challenges.restorePin";
    readonly ChallengesSetPin: "challenges.setPin";
    readonly ChallengesSetSecurityQuestions: "challenges.setSecurityQuestions";
    readonly Contracts: "contracts.*";
    readonly ContractsEventLog: "contracts.eventLog";
    readonly ModularWallet: "modularWallet.*";
    readonly ModularWalletUserOperation: "modularWallet.userOperation";
    readonly ModularWalletInboundTransfer: "modularWallet.inboundTransfer";
    readonly ModularWalletOutboundTransfer: "modularWallet.outboundTransfer";
    readonly TravelRule: "travelRule.*";
    readonly TravelRuleStatusUpdate: "travelRule.statusUpdate";
    readonly TravelRuleDeny: "travelRule.deny";
    readonly TravelRuleApprove: "travelRule.approve";
    readonly RampSession: "rampSession.*";
    readonly RampSessionCompleted: "rampSession.completed";
    readonly RampSessionDepositReceived: "rampSession.depositReceived";
    readonly RampSessionExpired: "rampSession.expired";
    readonly RampSessionFailed: "rampSession.failed";
    readonly RampSessionKycApproved: "rampSession.kycApproved";
    readonly RampSessionKycRejected: "rampSession.kycRejected";
    readonly RampSessionKycSubmitted: "rampSession.kycSubmitted";
};
type NotificationType = typeof NotificationType[keyof typeof NotificationType];

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * Required parameters to create a new subscription.
 * @export
 * @interface CreateSubscriptionRequest
 */
interface CreateSubscriptionRequest {
    /**
     * URL of the endpoint to subscribe to notifications. Must be publicly accessible, use HTTPS, and respond with a 2XX status to a POST request.
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    'endpoint': string;
    /**
     * The notification types to subscribe to. If not provided, the webhook will be unrestricted, and a notification is sent for every notification type. If the wildcard (`*`) or any combination of the wildcard and a set of notification types is provided, the webhook will also be unrestricted. If a set of notification types are provided, the webhook will be restricted. The restricted status of the webhook is returned in the response object. Each category of notification types also has a wildcard, which will restrict to all notification types from that category.
     * @type {Array<NotificationType>}
     * @memberof CreateSubscriptionRequest
     */
    'notificationTypes'?: Array<NotificationType>;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface DeleteMonitoredTokensRequest
 */
interface DeleteMonitoredTokensRequest {
    /**
     * Token ids to be removed from the monitored tokens list. Once removed, these tokens will no longer be shown by default when fetching wallet balances.
     * @type {Array<string>}
     * @memberof DeleteMonitoredTokensRequest
     */
    'tokenIds': Array<string>;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface EntityConfigData
 */
interface EntityConfigData {
    /**
     * System-generated unique identifier of the resource.
     * @type {string}
     * @memberof EntityConfigData
     */
    'appId'?: string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface EntityConfig
 */
interface EntityConfig {
    /**
     *
     * @type {EntityConfigData}
     * @memberof EntityConfig
     */
    'data'?: EntityConfigData;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The testnet blockchain network the resource will be created on or is currently on.
 * @export
 * @enum {string}
 */
declare const TestnetBlockchain: {
    readonly EthSepolia: "ETH-SEPOLIA";
    readonly AvaxFuji: "AVAX-FUJI";
    readonly MaticAmoy: "MATIC-AMOY";
    readonly SolDevnet: "SOL-DEVNET";
    readonly ArbSepolia: "ARB-SEPOLIA";
    readonly UniSepolia: "UNI-SEPOLIA";
    readonly BaseSepolia: "BASE-SEPOLIA";
    readonly OpSepolia: "OP-SEPOLIA";
};
type TestnetBlockchain = typeof TestnetBlockchain[keyof typeof TestnetBlockchain];

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface FaucetRequest
 */
interface FaucetRequest {
    /**
     * Blockchain generated unique identifier, associated with wallet (account), smart contract or other blockchain objects.
     * @type {string}
     * @memberof FaucetRequest
     */
    'address': string;
    /**
     *
     * @type {TestnetBlockchain}
     * @memberof FaucetRequest
     */
    'blockchain': TestnetBlockchain;
    /**
     * Request native testnet tokens.
     * @type {boolean}
     * @memberof FaucetRequest
     */
    'native'?: boolean;
    /**
     * Request USDC testnet tokens.
     * @type {boolean}
     * @memberof FaucetRequest
     */
    'usdc'?: boolean;
    /**
     * Request EURC testnet tokens.
     * @type {boolean}
     * @memberof FaucetRequest
     */
    'eurc'?: boolean;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface ModelError
 */
interface ModelError {
    /**
     * Code that corresponds to the error.
     * @type {number}
     * @memberof ModelError
     */
    'code': number;
    /**
     * Message that describes the error.
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @enum {string}
 */
declare const TokenStandard: {
    readonly Erc20: "ERC20";
    readonly Erc721: "ERC721";
    readonly Erc1155: "ERC1155";
    readonly Fungible: "Fungible";
    readonly FungibleAsset: "FungibleAsset";
    readonly NonFungible: "NonFungible";
    readonly NonFungibleEdition: "NonFungibleEdition";
    readonly ProgrammableNonFungible: "ProgrammableNonFungible";
    readonly ProgrammableNonFungibleEdition: "ProgrammableNonFungibleEdition";
};
type TokenStandard = typeof TokenStandard[keyof typeof TokenStandard];

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Token
 */
interface Token {
    /**
     * System-generated unique identifier of the resource.
     * @type {string}
     * @memberof Token
     */
    'id': string;
    /**
     * Blockchain name of the specified token.
     * @type {string}
     * @memberof Token
     */
    'name'?: string;
    /**
     *
     * @type {TokenStandard}
     * @memberof Token
     */
    'standard'?: TokenStandard;
    /**
     *
     * @type {Blockchain}
     * @memberof Token
     */
    'blockchain': Blockchain;
    /**
     * Number of decimal places shown in the token amount.
     * @type {number}
     * @memberof Token
     */
    'decimals'?: number;
    /**
     * Defines if the token is a native token of the specified blockchain. If TRUE, the token is a native token.
     * @type {boolean}
     * @memberof Token
     */
    'isNative': boolean;
    /**
     * Blockchain symbol of the specified token.
     * @type {string}
     * @memberof Token
     */
    'symbol'?: string;
    /**
     * Blockchain generated unique identifier, associated with wallet (account), smart contract or other blockchain objects.
     * @type {string}
     * @memberof Token
     */
    'tokenAddress'?: string;
    /**
     * Date and time the resource was last updated, in ISO-8601 UTC format.
     * @type {string}
     * @memberof Token
     */
    'updateDate': string;
    /**
     * Date and time the resource was created, in ISO-8601 UTC format.
     * @type {string}
     * @memberof Token
     */
    'createDate': string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @enum {string}
 */
declare const TokenMonitorScope: {
    readonly Selected: "SELECTED";
    readonly MonitorAll: "MONITOR_ALL";
};
type TokenMonitorScope = typeof TokenMonitorScope[keyof typeof TokenMonitorScope];

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface MonitoredTokensData
 */
interface MonitoredTokensData {
    /**
     *
     * @type {TokenMonitorScope}
     * @memberof MonitoredTokensData
     */
    'scope'?: TokenMonitorScope;
    /**
     * The list of tokens that have been added to the monitored tokens list. When fetching wallet balances, only these tokens will be shown by default.
     * @type {Array<Token>}
     * @memberof MonitoredTokensData
     */
    'tokens'?: Array<Token>;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface MonitoredTokens
 */
interface MonitoredTokens {
    /**
     *
     * @type {MonitoredTokensData}
     * @memberof MonitoredTokens
     */
    'data'?: MonitoredTokensData;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface NotAuthorizedResponse
 */
interface NotAuthorizedResponse {
    /**
     * Code that corresponds to the error.
     * @type {number}
     * @memberof NotAuthorizedResponse
     */
    'code': number;
    /**
     * Message that describes the error.
     * @type {string}
     * @memberof NotAuthorizedResponse
     */
    'message': string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface NotFoundResponse
 */
interface NotFoundResponse {
    /**
     * Code that corresponds to the error.
     * @type {number}
     * @memberof NotFoundResponse
     */
    'code': number;
    /**
     * Message that describes the error.
     * @type {string}
     * @memberof NotFoundResponse
     */
    'message': string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface NotificationSignaturePublicKeyData
 */
interface NotificationSignaturePublicKeyData {
    /**
     *
     * @type {string}
     * @memberof NotificationSignaturePublicKeyData
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof NotificationSignaturePublicKeyData
     */
    'algorithm': string;
    /**
     *
     * @type {string}
     * @memberof NotificationSignaturePublicKeyData
     */
    'publicKey': string;
    /**
     *
     * @type {string}
     * @memberof NotificationSignaturePublicKeyData
     */
    'createDate': string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface NotificationSignaturePublicKey
 */
interface NotificationSignaturePublicKey {
    /**
     *
     * @type {NotificationSignaturePublicKeyData}
     * @memberof NotificationSignaturePublicKey
     */
    'data'?: NotificationSignaturePublicKeyData;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Ping
 */
interface Ping {
    /**
     * Response to a ping.
     * @type {string}
     * @memberof Ping
     */
    'message': string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface PublicKeyData
 */
interface PublicKeyData {
    /**
     *
     * @type {string}
     * @memberof PublicKeyData
     */
    'publicKey'?: string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface PublicKey
 */
interface PublicKey {
    /**
     *
     * @type {PublicKeyData}
     * @memberof PublicKey
     */
    'data'?: PublicKeyData;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * Contains information about a webhook notification subscription.
 * @export
 * @interface Subscription
 */
interface Subscription {
    /**
     * System-generated unique identifier of the resource.
     * @type {string}
     * @memberof Subscription
     */
    'id': string;
    /**
     * Name of the webhook notification subscription.
     * @type {string}
     * @memberof Subscription
     */
    'name': string;
    /**
     * URL of the endpoint subscribing to notifications. Must be enabled to receive notifications.
     * @type {string}
     * @memberof Subscription
     */
    'endpoint': string;
    /**
     * Whether the subscription is enabled. `true` indicates the subscription is enabled.
     * @type {boolean}
     * @memberof Subscription
     */
    'enabled': boolean;
    /**
     * Date and time the resource was created, in ISO-8601 UTC format.
     * @type {string}
     * @memberof Subscription
     */
    'createDate': string;
    /**
     * Date and time the resource was last updated, in ISO-8601 UTC format.
     * @type {string}
     * @memberof Subscription
     */
    'updateDate': string;
    /**
     * The notification types on which a notification will be sent.
     * @type {Array<NotificationType>}
     * @memberof Subscription
     */
    'notificationTypes'?: Array<NotificationType>;
    /**
     * Whether the webhook is restricted to specific notification types. An unrestricted webhook will notify on all notification types. A restricted webhook will only notify on the notification types in the `notificationTypes` field.
     * @type {boolean}
     * @memberof Subscription
     */
    'restricted'?: boolean;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface SubscriptionResponse
 */
interface SubscriptionResponse {
    /**
     *
     * @type {Subscription}
     * @memberof SubscriptionResponse
     */
    'data'?: Subscription;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Subscriptions
 */
interface Subscriptions {
    /**
     *
     * @type {Array<Subscription>}
     * @memberof Subscriptions
     */
    'data'?: Array<Subscription>;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface UpdateMonitoredTokensRequest
 */
interface UpdateMonitoredTokensRequest {
    /**
     * The list of tokens that will be added to the monitored tokens list. When fetching wallet balances, these tokens will be shown by default.
     * @type {Array<string>}
     * @memberof UpdateMonitoredTokensRequest
     */
    'tokenIds'?: Array<string>;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface UpdateMonitoredTokensScopeRequest
 */
interface UpdateMonitoredTokensScopeRequest {
    /**
     *
     * @type {TokenMonitorScope}
     * @memberof UpdateMonitoredTokensScopeRequest
     */
    'scope': TokenMonitorScope;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface UpdateSubscriptionRequest
 */
interface UpdateSubscriptionRequest {
    /**
     * Name of the subscription.
     * @type {string}
     * @memberof UpdateSubscriptionRequest
     */
    'name': string;
    /**
     * Whether the subscription is enabled. `true` indicates the subscription is active.
     * @type {boolean}
     * @memberof UpdateSubscriptionRequest
     */
    'enabled': boolean;
}

/**
 * DeveloperAccountApi - axios parameter creator
 * @export
 */
declare const DeveloperAccountApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get the app ID associated to the entity.
     * @summary Get configuration for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityConfig: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the public key associated with the entity.
     * @summary Get public key for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicKey: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * DeveloperAccountApi - functional programming interface
 * @export
 */
declare const DeveloperAccountApiFp: (configuration?: Configuration) => {
    /**
     * Get the app ID associated to the entity.
     * @summary Get configuration for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityConfig>>;
    /**
     * Get the public key associated with the entity.
     * @summary Get public key for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>>;
};
/**
 * DeveloperAccountApi - factory interface
 * @export
 */
declare const DeveloperAccountApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get the app ID associated to the entity.
     * @summary Get configuration for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityConfig(options?: any): AxiosPromise<EntityConfig>;
    /**
     * Get the public key associated with the entity.
     * @summary Get public key for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicKey(options?: any): AxiosPromise<PublicKey>;
};
/**
 * DeveloperAccountApi - object-oriented interface
 * @export
 * @class DeveloperAccountApi
 * @extends {BaseAPI}
 */
declare class DeveloperAccountApi extends BaseAPI {
    /**
     * Get the app ID associated to the entity.
     * @summary Get configuration for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperAccountApi
     */
    getEntityConfig(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<EntityConfig, any>>;
    /**
     * Get the public key associated with the entity.
     * @summary Get public key for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperAccountApi
     */
    getPublicKey(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<PublicKey, any>>;
}

/**
 * FaucetApi - axios parameter creator
 * @export
 */
declare const FaucetApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Request testnet tokens for your wallet.
     * @summary Request testnet tokens
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {FaucetRequest} [faucetRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestTestnetTokens: (xRequestId?: string, faucetRequest?: FaucetRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FaucetApi - functional programming interface
 * @export
 */
declare const FaucetApiFp: (configuration?: Configuration) => {
    /**
     * Request testnet tokens for your wallet.
     * @summary Request testnet tokens
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {FaucetRequest} [faucetRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestTestnetTokens(xRequestId?: string, faucetRequest?: FaucetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * FaucetApi - factory interface
 * @export
 */
declare const FaucetApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Request testnet tokens for your wallet.
     * @summary Request testnet tokens
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {FaucetRequest} [faucetRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestTestnetTokens(xRequestId?: string, faucetRequest?: FaucetRequest, options?: any): AxiosPromise<void>;
};
/**
 * FaucetApi - object-oriented interface
 * @export
 * @class FaucetApi
 * @extends {BaseAPI}
 */
declare class FaucetApi extends BaseAPI {
    /**
     * Request testnet tokens for your wallet.
     * @summary Request testnet tokens
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {FaucetRequest} [faucetRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaucetApi
     */
    requestTestnetTokens(xRequestId?: string, faucetRequest?: FaucetRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
declare const HealthApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Checks that the service is running.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * HealthApi - functional programming interface
 * @export
 */
declare const HealthApiFp: (configuration?: Configuration) => {
    /**
     * Checks that the service is running.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ping>>;
};
/**
 * HealthApi - factory interface
 * @export
 */
declare const HealthApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Checks that the service is running.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: any): AxiosPromise<Ping>;
};
/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
declare class HealthApi extends BaseAPI {
    /**
     * Checks that the service is running.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    ping(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Ping, any>>;
}

/**
 * MonitorTokensApi - axios parameter creator
 * @export
 */
declare const MonitorTokensApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Add a new token to the monitored token list.
     * @summary Set monitored tokens
     * @param {CreateMonitoredTokensRequest} createMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMonitoredTokens: (createMonitoredTokensRequest: CreateMonitoredTokensRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete tokens from the monitored token list.
     * @summary Delete monitored tokens
     * @param {DeleteMonitoredTokensRequest} deleteMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMonitoredTokens: (deleteMonitoredTokensRequest: DeleteMonitoredTokensRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get monitored tokens
     * @summary Retrieve existing monitored tokens.
     * @param {Blockchain} [blockchain] Filter by blockchain.
     * @param {string} [tokenAddress] Filter by token address.
     * @param {string} [symbol] Filter by token symbol.
     * @param {string} [from] Queries items created since the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [to] Queries items created before the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjunction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjunction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMonitoredTokens: (blockchain?: Blockchain, tokenAddress?: string, symbol?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Upsert the monitored token list.
     * @summary Update monitored tokens
     * @param {UpdateMonitoredTokensRequest} updateMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMonitoredTokens: (updateMonitoredTokensRequest: UpdateMonitoredTokensRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Select between monitoring all tokens or selected tokens added to the monitored tokens list.
     * @summary Update monitored tokens scope
     * @param {UpdateMonitoredTokensScopeRequest} updateMonitoredTokensScopeRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMonitoredTokensScope: (updateMonitoredTokensScopeRequest: UpdateMonitoredTokensScopeRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * MonitorTokensApi - functional programming interface
 * @export
 */
declare const MonitorTokensApiFp: (configuration?: Configuration) => {
    /**
     * Add a new token to the monitored token list.
     * @summary Set monitored tokens
     * @param {CreateMonitoredTokensRequest} createMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMonitoredTokens(createMonitoredTokensRequest: CreateMonitoredTokensRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonitoredTokens>>;
    /**
     * Delete tokens from the monitored token list.
     * @summary Delete monitored tokens
     * @param {DeleteMonitoredTokensRequest} deleteMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMonitoredTokens(deleteMonitoredTokensRequest: DeleteMonitoredTokensRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Get monitored tokens
     * @summary Retrieve existing monitored tokens.
     * @param {Blockchain} [blockchain] Filter by blockchain.
     * @param {string} [tokenAddress] Filter by token address.
     * @param {string} [symbol] Filter by token symbol.
     * @param {string} [from] Queries items created since the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [to] Queries items created before the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjunction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjunction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMonitoredTokens(blockchain?: Blockchain, tokenAddress?: string, symbol?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonitoredTokens>>;
    /**
     * Upsert the monitored token list.
     * @summary Update monitored tokens
     * @param {UpdateMonitoredTokensRequest} updateMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMonitoredTokens(updateMonitoredTokensRequest: UpdateMonitoredTokensRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonitoredTokens>>;
    /**
     * Select between monitoring all tokens or selected tokens added to the monitored tokens list.
     * @summary Update monitored tokens scope
     * @param {UpdateMonitoredTokensScopeRequest} updateMonitoredTokensScopeRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMonitoredTokensScope(updateMonitoredTokensScopeRequest: UpdateMonitoredTokensScopeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * MonitorTokensApi - factory interface
 * @export
 */
declare const MonitorTokensApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Add a new token to the monitored token list.
     * @summary Set monitored tokens
     * @param {CreateMonitoredTokensRequest} createMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMonitoredTokens(createMonitoredTokensRequest: CreateMonitoredTokensRequest, options?: any): AxiosPromise<MonitoredTokens>;
    /**
     * Delete tokens from the monitored token list.
     * @summary Delete monitored tokens
     * @param {DeleteMonitoredTokensRequest} deleteMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMonitoredTokens(deleteMonitoredTokensRequest: DeleteMonitoredTokensRequest, options?: any): AxiosPromise<void>;
    /**
     * Get monitored tokens
     * @summary Retrieve existing monitored tokens.
     * @param {Blockchain} [blockchain] Filter by blockchain.
     * @param {string} [tokenAddress] Filter by token address.
     * @param {string} [symbol] Filter by token symbol.
     * @param {string} [from] Queries items created since the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [to] Queries items created before the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjunction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjunction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMonitoredTokens(blockchain?: Blockchain, tokenAddress?: string, symbol?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<MonitoredTokens>;
    /**
     * Upsert the monitored token list.
     * @summary Update monitored tokens
     * @param {UpdateMonitoredTokensRequest} updateMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMonitoredTokens(updateMonitoredTokensRequest: UpdateMonitoredTokensRequest, options?: any): AxiosPromise<MonitoredTokens>;
    /**
     * Select between monitoring all tokens or selected tokens added to the monitored tokens list.
     * @summary Update monitored tokens scope
     * @param {UpdateMonitoredTokensScopeRequest} updateMonitoredTokensScopeRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMonitoredTokensScope(updateMonitoredTokensScopeRequest: UpdateMonitoredTokensScopeRequest, options?: any): AxiosPromise<void>;
};
/**
 * MonitorTokensApi - object-oriented interface
 * @export
 * @class MonitorTokensApi
 * @extends {BaseAPI}
 */
declare class MonitorTokensApi extends BaseAPI {
    /**
     * Add a new token to the monitored token list.
     * @summary Set monitored tokens
     * @param {CreateMonitoredTokensRequest} createMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorTokensApi
     */
    createMonitoredTokens(createMonitoredTokensRequest: CreateMonitoredTokensRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<MonitoredTokens, any>>;
    /**
     * Delete tokens from the monitored token list.
     * @summary Delete monitored tokens
     * @param {DeleteMonitoredTokensRequest} deleteMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorTokensApi
     */
    deleteMonitoredTokens(deleteMonitoredTokensRequest: DeleteMonitoredTokensRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Get monitored tokens
     * @summary Retrieve existing monitored tokens.
     * @param {Blockchain} [blockchain] Filter by blockchain.
     * @param {string} [tokenAddress] Filter by token address.
     * @param {string} [symbol] Filter by token symbol.
     * @param {string} [from] Queries items created since the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [to] Queries items created before the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjunction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjunction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorTokensApi
     */
    listMonitoredTokens(blockchain?: Blockchain, tokenAddress?: string, symbol?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<MonitoredTokens, any>>;
    /**
     * Upsert the monitored token list.
     * @summary Update monitored tokens
     * @param {UpdateMonitoredTokensRequest} updateMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorTokensApi
     */
    updateMonitoredTokens(updateMonitoredTokensRequest: UpdateMonitoredTokensRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<MonitoredTokens, any>>;
    /**
     * Select between monitoring all tokens or selected tokens added to the monitored tokens list.
     * @summary Update monitored tokens scope
     * @param {UpdateMonitoredTokensScopeRequest} updateMonitoredTokensScopeRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorTokensApi
     */
    updateMonitoredTokensScope(updateMonitoredTokensScopeRequest: UpdateMonitoredTokensScopeRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
}

/**
 * WebhookSubscriptionsApi - axios parameter creator
 * @export
 */
declare const WebhookSubscriptionsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a notification subscription by configuring an endpoint to receive notifications. For details, see the [Notification Flows](https://developers.circle.com/w3s/docs/notification-flows) guide.
     * @summary Create a notification subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest Schema for the request payload to create a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSubscription: (createSubscriptionRequest: CreateSubscriptionRequest, xRequestId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete an existing subscription.
     * @summary Delete a notification subscription
     * @param {string} id The universally unique identifier of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscription: (id: string, xRequestId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the public key and algorithm used to digitally sign webhook notifications. Verifying the digital signature ensures the notification came from Circle.  In the headers of each webhook, you can find   1. `X-Circle-Signature`: a header containing the digital signature generated by Circle.   2. `X-Circle-Key-Id`: a header containing the UUID. This is will be used as the `ID` as URL parameter to retrieve the relevant public key.
     * @summary Get a notification signature public key
     * @param {string} id The universally unique identifier of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSignature: (id: string, xRequestId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve an existing notification subscription.
     * @summary Retrieve a notification subscription
     * @param {string} id The universally unique identifier of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscription: (id: string, xRequestId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve an array of existing notification subscriptions.
     * @summary Get all notification subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptions: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update subscription endpoint to receive notifications.
     * @summary Update a notification subscription
     * @param {string} id The universally unique identifier of the resource.
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest Schema for the request payload to update a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSubscription: (id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, xRequestId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * WebhookSubscriptionsApi - functional programming interface
 * @export
 */
declare const WebhookSubscriptionsApiFp: (configuration?: Configuration) => {
    /**
     * Create a notification subscription by configuring an endpoint to receive notifications. For details, see the [Notification Flows](https://developers.circle.com/w3s/docs/notification-flows) guide.
     * @summary Create a notification subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest Schema for the request payload to create a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSubscription(createSubscriptionRequest: CreateSubscriptionRequest, xRequestId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionResponse>>;
    /**
     * Delete an existing subscription.
     * @summary Delete a notification subscription
     * @param {string} id The universally unique identifier of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscription(id: string, xRequestId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Get the public key and algorithm used to digitally sign webhook notifications. Verifying the digital signature ensures the notification came from Circle.  In the headers of each webhook, you can find   1. `X-Circle-Signature`: a header containing the digital signature generated by Circle.   2. `X-Circle-Key-Id`: a header containing the UUID. This is will be used as the `ID` as URL parameter to retrieve the relevant public key.
     * @summary Get a notification signature public key
     * @param {string} id The universally unique identifier of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSignature(id: string, xRequestId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSignaturePublicKey>>;
    /**
     * Retrieve an existing notification subscription.
     * @summary Retrieve a notification subscription
     * @param {string} id The universally unique identifier of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscription(id: string, xRequestId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionResponse>>;
    /**
     * Retrieve an array of existing notification subscriptions.
     * @summary Get all notification subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriptions>>;
    /**
     * Update subscription endpoint to receive notifications.
     * @summary Update a notification subscription
     * @param {string} id The universally unique identifier of the resource.
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest Schema for the request payload to update a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSubscription(id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, xRequestId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionResponse>>;
};
/**
 * WebhookSubscriptionsApi - factory interface
 * @export
 */
declare const WebhookSubscriptionsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a notification subscription by configuring an endpoint to receive notifications. For details, see the [Notification Flows](https://developers.circle.com/w3s/docs/notification-flows) guide.
     * @summary Create a notification subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest Schema for the request payload to create a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSubscription(createSubscriptionRequest: CreateSubscriptionRequest, xRequestId?: string, options?: any): AxiosPromise<SubscriptionResponse>;
    /**
     * Delete an existing subscription.
     * @summary Delete a notification subscription
     * @param {string} id The universally unique identifier of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscription(id: string, xRequestId?: string, options?: any): AxiosPromise<void>;
    /**
     * Get the public key and algorithm used to digitally sign webhook notifications. Verifying the digital signature ensures the notification came from Circle.  In the headers of each webhook, you can find   1. `X-Circle-Signature`: a header containing the digital signature generated by Circle.   2. `X-Circle-Key-Id`: a header containing the UUID. This is will be used as the `ID` as URL parameter to retrieve the relevant public key.
     * @summary Get a notification signature public key
     * @param {string} id The universally unique identifier of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSignature(id: string, xRequestId?: string, options?: any): AxiosPromise<NotificationSignaturePublicKey>;
    /**
     * Retrieve an existing notification subscription.
     * @summary Retrieve a notification subscription
     * @param {string} id The universally unique identifier of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscription(id: string, xRequestId?: string, options?: any): AxiosPromise<SubscriptionResponse>;
    /**
     * Retrieve an array of existing notification subscriptions.
     * @summary Get all notification subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptions(options?: any): AxiosPromise<Subscriptions>;
    /**
     * Update subscription endpoint to receive notifications.
     * @summary Update a notification subscription
     * @param {string} id The universally unique identifier of the resource.
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest Schema for the request payload to update a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSubscription(id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, xRequestId?: string, options?: any): AxiosPromise<SubscriptionResponse>;
};
/**
 * WebhookSubscriptionsApi - object-oriented interface
 * @export
 * @class WebhookSubscriptionsApi
 * @extends {BaseAPI}
 */
declare class WebhookSubscriptionsApi extends BaseAPI {
    /**
     * Create a notification subscription by configuring an endpoint to receive notifications. For details, see the [Notification Flows](https://developers.circle.com/w3s/docs/notification-flows) guide.
     * @summary Create a notification subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest Schema for the request payload to create a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookSubscriptionsApi
     */
    createSubscription(createSubscriptionRequest: CreateSubscriptionRequest, xRequestId?: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<SubscriptionResponse, any>>;
    /**
     * Delete an existing subscription.
     * @summary Delete a notification subscription
     * @param {string} id The universally unique identifier of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookSubscriptionsApi
     */
    deleteSubscription(id: string, xRequestId?: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Get the public key and algorithm used to digitally sign webhook notifications. Verifying the digital signature ensures the notification came from Circle.  In the headers of each webhook, you can find   1. `X-Circle-Signature`: a header containing the digital signature generated by Circle.   2. `X-Circle-Key-Id`: a header containing the UUID. This is will be used as the `ID` as URL parameter to retrieve the relevant public key.
     * @summary Get a notification signature public key
     * @param {string} id The universally unique identifier of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookSubscriptionsApi
     */
    getNotificationSignature(id: string, xRequestId?: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<NotificationSignaturePublicKey, any>>;
    /**
     * Retrieve an existing notification subscription.
     * @summary Retrieve a notification subscription
     * @param {string} id The universally unique identifier of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookSubscriptionsApi
     */
    getSubscription(id: string, xRequestId?: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<SubscriptionResponse, any>>;
    /**
     * Retrieve an array of existing notification subscriptions.
     * @summary Get all notification subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookSubscriptionsApi
     */
    getSubscriptions(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Subscriptions, any>>;
    /**
     * Update subscription endpoint to receive notifications.
     * @summary Update a notification subscription
     * @param {string} id The universally unique identifier of the resource.
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest Schema for the request payload to update a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookSubscriptionsApi
     */
    updateSubscription(id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, xRequestId?: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<SubscriptionResponse, any>>;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

interface ClientConfig {
    /**
     * ApiKey that will be used to authenticate the request
     */
    apiKey: string;
    /**
     * Version of the client. Will be added to the user agent.
     */
    version: string;
    /**
     * Customized user agent. Will be added to the user agent.
     */
    userAgent?: string;
}
declare class ConfigurationsClient {
    DeveloperAccount: ReturnType<typeof DeveloperAccountApiFactory>;
    Faucet: ReturnType<typeof FaucetApiFactory>;
    Health: ReturnType<typeof HealthApiFactory>;
    MonitorTokens: ReturnType<typeof MonitorTokensApiFactory>;
    WebhookSubscriptions: ReturnType<typeof WebhookSubscriptionsApiFactory>;
    constructor(baseUrl: string, config: ClientConfig, headers?: Record<string, string>);
}

export { type BadRequestResponse, Blockchain, ConfigurationsClient, type CreateMonitoredTokensRequest, type CreateSubscriptionRequest, type DeleteMonitoredTokensRequest, DeveloperAccountApi, DeveloperAccountApiAxiosParamCreator, DeveloperAccountApiFactory, DeveloperAccountApiFp, type EntityConfig, type EntityConfigData, FaucetApi, FaucetApiAxiosParamCreator, FaucetApiFactory, FaucetApiFp, type FaucetRequest, HealthApi, HealthApiAxiosParamCreator, HealthApiFactory, HealthApiFp, type ModelError, MonitorTokensApi, MonitorTokensApiAxiosParamCreator, MonitorTokensApiFactory, MonitorTokensApiFp, type MonitoredTokens, type MonitoredTokensData, type NotAuthorizedResponse, type NotFoundResponse, type NotificationSignaturePublicKey, type NotificationSignaturePublicKeyData, NotificationType, type Ping, type PublicKey, type PublicKeyData, type Subscription, type SubscriptionResponse, type Subscriptions, TestnetBlockchain, type Token, TokenMonitorScope, TokenStandard, type UpdateMonitoredTokensRequest, type UpdateMonitoredTokensScopeRequest, type UpdateSubscriptionRequest, WebhookSubscriptionsApi, WebhookSubscriptionsApiAxiosParamCreator, WebhookSubscriptionsApiFactory, WebhookSubscriptionsApiFp };
